using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public static class MarchingCubes
{
    public static int[] EdgeTable = new int[256]
    {
        0x0  , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
        0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
        0x190, 0x99 , 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
        0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
        0x230, 0x339, 0x33 , 0x13a, 0x636, 0x73f, 0x435, 0x53c,
        0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
        0x3a0, 0x2a9, 0x1a3, 0xaa , 0x7a6, 0x6af, 0x5a5, 0x4ac,
        0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
        0x460, 0x569, 0x663, 0x76a, 0x66 , 0x16f, 0x265, 0x36c,
        0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
        0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff , 0x3f5, 0x2fc,
        0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
        0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55 , 0x15c,
        0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
        0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc ,
        0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
        0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
        0xcc , 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
        0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
        0x15c, 0x55 , 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
        0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
        0x2fc, 0x3f5, 0xff , 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
        0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
        0x36c, 0x265, 0x16f, 0x66 , 0x76a, 0x663, 0x569, 0x460,
        0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
        0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa , 0x1a3, 0x2a9, 0x3a0,
        0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
        0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33 , 0x339, 0x230,
        0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
        0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99 , 0x190,
        0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
        0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0
    };

    public static float[,,] CreateRandomDensity(Vector3Int size, float variance = 1f)
    {
        var points = new float[size.x,size.y,size.z];

        for (int x = 0; x < size.x; x++)
        {
            for (int y = 0; y < size.y; y++)
            {
                for (int z = 0; z < size.z; z++)
                {
                    // random range
                    points[x, y, z] = Random.Range(-variance, variance);
                }
            }
        }

        return points;
    }

    public static MeshData MarchCubes(float[,,] samples, float groundLevel)
    {
        var meshData = new MeshData();

        var xLength = samples.GetLength(0);
        var yLength = samples.GetLength(1);
        var zLength = samples.GetLength(2);

        /*
        // Start at origin of float samples and work through x, y and z respectivley
        for (int z = 0; z < zLength; z++)
        {
            for (int y = 0; y < yLength; y++)
            {
                for (int x = 0; x < xLength; x++)
                {

                }
            }
        }
        */

        // Temporary: just make the first cube
        var verts = new List<Vector3>();
        var tris = new List<int>();        

        // Assign sample points for first cube
        var sampleIndexes = new float[]
        {
            samples[0,0,0],
            samples[0,0,1],
            samples[1,0,1],
            samples[1,0,0],
            samples[0,1,0],
            samples[0,1,1],
            samples[1,1,1],
            samples[1,1,0]
        };

        // Get lookup index
        var cubeIndex = 0;
        if (sampleIndexes[0] < groundLevel) cubeIndex |= 1;
        if (sampleIndexes[1] < groundLevel) cubeIndex |= 2;
        if (sampleIndexes[2] < groundLevel) cubeIndex |= 4;
        if (sampleIndexes[3] < groundLevel) cubeIndex |= 8;
        if (sampleIndexes[4] < groundLevel) cubeIndex |= 12;
        if (sampleIndexes[5] < groundLevel) cubeIndex |= 32;
        if (sampleIndexes[6] < groundLevel) cubeIndex |= 64;
        if (sampleIndexes[7] < groundLevel) cubeIndex |= 128;

        // Find intersecting edges
        var intersections = new BitArray(EdgeTable[cubeIndex]);

        // Create nodes at intersection points
        if (intersections[0])
        {
            // need to bring worldspace in with sample map
            verts.Add(Vector3.Lerp())
        }

        return meshData;
    }
}
public struct CubeFieldSample
{
    public Vector3 WorldSpace;
    public float Value;
    
    public CubeFieldSample(Vector3 worldSpace, float value)
    {
        WorldSpace = worldSpace;
        Value = value;
    }
    public CubeFieldSample(Vector3 worldSpace)
        : this(worldSpace, 0f) { }    
}